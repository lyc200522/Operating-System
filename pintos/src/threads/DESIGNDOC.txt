            +--------------------+
            |        CS 140      |
            | PROJECT 1: THREADS |
            |   DESIGN DOCUMENT  |
            +--------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

刘禹辰 18373223
陈新钰 18373198
李柯凡 18373238
陈振涛 18373285

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

                 ALARM CLOCK
                 ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Add to struct thread:

    /* Member to implementing thread_sleep(). */
    int64_t ticks_to_wakeup;            /* Ticks taken to be waken */
    struct list_elem sleepelem;         /* List element for sleeping blocked threads List */

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

thread_sleep() gets the current thread and give the member ticks_to_sleep the value of ticks,
 the only input argument of the function. Then put the thread to the sleep list, and block set
 the current thread status to THREAD_BLOCKED. After triggering the timer interrupt handler,
 the timer since OS booting will increase by one tick.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

we build a thread list sleep_list as sleeping thread pool, then when the timer interrupt handler
 try to awake sleeping thread, it can just do that without check the thread status and search 
 from all threads.

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

When timer_sleep() are called by the current thread, the interrupts will be disabled, so this operation
 is atomic operation, which won't be disturbed.

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

The interrupt will be disabled during timer_sleep(), so the race condition will not happen when
 in the above condition.

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

Sleeping thread pool is good for using the original data structure, and make it easier to search for threads
 that have a time to be awaken from the blocked threads. It's better than the ordered list because we try to 
lessen the time that interrupt handler taken by moving the order algorithm away.

             PRIORITY SCHEDULING
             ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

添加到 struct lock
    struct list_elem lockelem;  /* 锁的元素，为了加入线程的hold_locks列表中 */
    int max_thread_priority;    
    /* 等待锁的线程的最大优先级，根据这个值在hold_locks列表中查找捐赠的最大优先级 */

添加到 struct thread
    struct list hold_locks;     /* 存储此线程拥有的锁 */
    struct lock *waiting_lock;  /* 此线程等待的锁，实现递归捐赠 */
    int original_priority;      /* 此线程被捐赠前的优先级，为了恢复线程的原本优先级 */


>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

struct lock 中，lockelem是一个list的元素类型的变量，如果锁被某个线程拥有，则加入 struct thread
的 hold_locks 列表中；max_thread_priority存储等待锁的线程的最大优先级。

struct thread 中，hold_locks列表存储线程拥有的锁，当有更高优先级的线程申请这些锁的时候，
可以提高此线程的优先级；waiting_lock存储此线程等待的锁，当有线程等待此线程拥有的锁，且此
线程同时等待另一个线程拥有的锁的时候，实现递归捐赠优先级；original_priority存储此线程原
本的优先级，如果此线程拥有的锁的max_thread_priority的值没有比original_priority大的，则
恢复此线程的原本优先级。




---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

等待锁和信号量的线程存放在一个根据线程的优先级排序的优先队列中，按照优先级大小依次唤醒。


>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

当前线程申请某个锁的时候，首先判断是否使用循环调度，如果使用，判断锁是否被其它线程拥有。
如果有，假设此线程为线程A。判断当前线程的优先级是否大于锁的最大优先级，如果大于则更改锁
的最大优先级，进行优先级捐赠部分。

捐赠优先级部分：首先提高锁的最大优先级，如果线程A的优先级小于锁的最大优先级则提高线程A的
优先级。

如果线程A等待的锁，被另一个线程拥有，则发生递归捐赠nested donation。此处需要用一个循环来
实现，循环条件为：线程等待的锁不为空且阻塞的线程的优先级大于拥有锁的线程的优先级。循环中
设置锁为当前线程等待的锁，并查找拥有线程A等待的锁的线程B，实现递归捐赠优先级，直到线程没有
等待的锁为止。


>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

在循环调度的情况下，首先从当前线程拥有的锁的队列中移除锁，然后在当前线程的锁队列中找到优先级
最高的锁，将max(锁的优先级，当前线程的原本优先级)设置为当前线程的优先级。



---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?




---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?




              ADVANCED SCHEDULER
              ==================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

changed 'struct' member: int nice; int recent_cpu;
nice:nice的值用于影响线程优先级，值为正数降低此线程的优先级，负数则相反。(-20<=nice<=20)
recent_cpu:recent_cpu的值用于衡量一个线程最近获得CPU的时间。
changed global variable: static int load_avg;
load_avg:load_avg的值用于估计过去一分钟内准备运行的平均线程数。

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0      0   0   0   63  61  59     A
 4      4   0   0   62  61  59     A
 8      8   0   0   61  61  59     A
12      12  0   0   60  61  59     B
16      12  4   0   60  60  59     A
20      16  4   0   59  60  59     B
24      16  8   0   59  59  59     A
28      20  8   0   58  59  59     B
32      20  12  0   58  58  59     C
36      20  12  4   58  58  58     A

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

    在计算priority，recent_cpu，load_avg这三个数值的公式中都涉及了浮点数的运算，
这些计算过程中会出现数值上的舍入，可能会导致数值不确定。使用定点数学的算理。调度
与之相匹配。

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

    通过调度程序平衡线程的不同调度需求，兼容不同类型的线程，比如需要快速响应的
I/O线程，需要大量CPU时间的复杂计算线程。使得整体的调度成本降低，提高了性能。

---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

优点：
    1.使用了宏实现了fixe point算法，轻巧方便。
    2.断言使用完整，保证出错时能及时终止。
    3.
缺点：
改进：

>> C6: The assignment explains arithmetic for fixed-point math in
>> detail, but it leaves it open to you to implement it.  Why did you
>> decide to implement it the way you did?  If you created an
>> abstraction layer for fixed-point math, that is, an abstract data
>> type and/or a set of functions or macros to manipulate fixed-point
>> numbers, why did you do so?  If not, why not?

    这次实验中采用的是新建一个fixed_point.h文件，在其中写好一组实现各种定点数
算法的宏。采用此种方式首先调用起来会很方便。其次是能够使用的范围广泛，只要include
此文件就可以在任意地方调用。宏可以直接在源代码中打开，运行时不需再分配内存。而
此算法并不复杂，所以直接使用宏优势比函数明显。

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?